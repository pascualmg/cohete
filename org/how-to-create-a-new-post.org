#+TITLE: How to create a post    .

* Define your router file in your .env

#+begin_src php
ROUTES_PATH=/Users/passh/src/php/reactor/src/ddd/Infrastructure/HttpServer/Router/routes.json

#+end_src

* Arrancamos el cohete.
- Entramos en el directorio del proyecto y ejecutamos
  #+begin_src bash
  nix develop
  #+end_src

  #+begin_quote
  Hay que tener en cuenta que nix debe estar instalado en el sistema , y las experimental features nix-command y flakes deben estar activas .
  #+end_quote

  Una vez dentro  de esta consola dispondremos de la version de php indicada con xdebug , ya que por defecto se arranca con estos m칩dulos en la shell de desarrollo.

* Create a new entry for the new =Controller/HttpRequestHandler=

#+begin_src php
[
  {
    "method": "POST",
    "path": "/post",
    "handler": "\\pascualmg\\reactor\\ddd\\Infrastructure\\HttpServer\\RequestHandler\\CreatePostController"
  }
]
#+end_src php

* Create the =Controller=


Este seria el skel del que partir, no hace nada mas que responder con un 200 que no es poco 游땐

#+begin_src php
<?php

namespace pascualmg\reactor\ddd\Infrastructure\HttpServer\RequestHandler;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use React\Http\Message\Response;
use React\Promise\PromiseInterface;

class CreatePostController implements HttpRequestHandler
{

    public function __invoke(ServerRequestInterface $request, ?array $routeParams): ResponseInterface|PromiseInterface //of a response Interface
    {
        return new Response();
    }
}

#+end_src

** Una "larga y necesaria aclaraci칩n" antes de seguir.

Todos los Condroladores , deben implementar =HttpRequestHandler= , no ha de verse como una restricci칩n en absoluto, ya que reactPHP no impone aqu칤 ninguna restricci칩n se podria usar una lamda cualquiera, este tipado lo brinda el microFramework 游 , En este caso ese tipado es algo que nos brinda una clara visi칩n de lo que puede o no hacer, y debe o no hacer , nuestro controlador.

En esa firma es donde se define, ahora en php8 posibles valores de retorno, esto que podr칤a a priori parecer un smellcode si estamos con el chip funcional en mente,  por que as칤 a simple vista logicamente no es una funci칩n pura, pero si lo pensamos bien , ser칤a la manera sint치ctica de tener un tipo polim칩rfico.

#+begin_quote
El comentario al final , indica que hay un lack en el lenguaje de php para representar ese concepto, esto tambi칠n nos va a pasar en sitios como los respositorios, donde , yo puedo devolver una promise , que se resolver치 en un array de post , y como programador lo debo de saber y respetar .

Lo importante es tenerlo claro , que si vas a devolver una promise, aka *deferred* o "en diferido ..." su _resolve_ *TIENE  QUE* devolver una =ResponseInterface= , este , es un punto clave a entender
ya que es como nuestro kernel espera que sea .
#+end_quote

* Vamos a por ese Content

Ahora que ya tenemos el controller devolviendo un 200 , es la hora de ver como obtenemos el payload que nos viene en la request , en este caso va a ser como un JSON , que contendr치 los par치metros necesarios para crear nuestra entidad ( y registro en la DDBB )

#+begin_src php
<?php

namespace pascualmg\reactor\ddd\Infrastructure\HttpServer\RequestHandler;

use pascualmg\reactor\ddd\Infrastructure\HttpServer\JsonResponse;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use React\Http\Message\Response;
use React\Promise\PromiseInterface;

class CreatePostController implements HttpRequestHandler
{

    public function __construct(
   //     private readonly PostCreator $postCreator
    )
    {
    }

    public function __invoke(ServerRequestInterface $request, ?array $routeParams): ResponseInterface|PromiseInterface
    {
        $body = $request->getBody()->getContents();
        try {
            $payload = json_decode($body, true, 512, JSON_THROW_ON_ERROR);
        } catch (\JsonException $e) {
            return JsonResponse::withError($e);
        }

        return new Response(
            200,
            ["Content-Type" => "application/json"],
            json_encode($payload)
        );
    }
}

#+end_src

 En la linea 96 ya tenemos la manera de obtener f치cilmente el json que nos viene de la request , una vez la obtenemos por el momento simplemente la devolvemos tal cual nos llegue.

#+begin_src bash :results output
curl -X POST --location "http://localhost:8000/post" \
    -H "Content-Type: application/json" \
    -d '{
          "foo": "bar"
        }'

#+end_src

 #+RESULTS:
 : {"foo":"bar"}

 Est치 funcionando tal como se espera , esto de evaluar c칩digo en el .org es _magic_


Lo m치s ortodoxo ser칤a pues hacer un Command Handler que llame al repo etc, pero por "simplificar"
el desarrollo inicialmente simplemente llamare al save del repo .

1. A침adido el nuevo m칠todo a la interfaz de dominio.

 
 #+begin_src


 #+end_src

* PostCreator domain service.
Es momento de implmentar este servicio de dominio, que se encargar치 de crear usando el =PostRepository=
