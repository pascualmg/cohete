Claro, aqu칤 te dejo el post completo en formato de texto plano con la sintaxis de .org. Recuerda copiar todo el contenido, incluyendo las l칤neas de c칩digo, y pegarlo en tu editor favorito:

```
#+TITLE: El tema del tema: KISS con Web Components
#+AUTHOR: Pascual M.G.
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="spacemacs.css">


춰Hola! 쮸lguna vez os hab칠is encontrado luchando con la gesti칩n de temas de colores en vuestros proyectos web?  Este quebradero de cabeza es tan com칰n como frustrante. 
Durante el desarrollo de mi Portfolio que he decido craftear desde cero, desde el back hasta el front, todo , vi que de alguna forma tendr칤a que dar a esto soluci칩n y esto es lo que se me ha ocurrido,  aunque simple, es sorprendentemente efectiva. Si est치is pensando que hace un back y no un front, es cierto, pero me gusta explorar tecnolog칤as , sean del sitio que sean si son la ?? como creo que son los Web Components, me gusta investigar y aprender.
Creo este post por que me ha parecido interesante compartirlo, y si a alguien le sirve de ayuda, pues mejor que mejor.

** El problema: Cuando los colores se vuelven un caos

Imaginad que est치is construyendo una aplicaci칩n web compleja. Ten칠is decenas, quiz치s cientos de componentes. Botones, formularios, paneles, modales... y todos necesitan seguir un esquema de colores coherente. Ahora, a침adid a eso la necesidad de tener m칰ltiples temas (modo claro, modo oscuro, 춰tal vez incluso un modo "Con tus colores del IDE " o "Pepa PIG"! quien sabe). De repente, lo que parec칤a un simple juego de colores se convierte en un problema log칤stico de proporciones 칠picas.

Tradicionalmente, muchos desarrolladores han recurrido a soluciones como:

1. Clases CSS gigantes que definen cada color para cada elemento.
2. Preprocesadores CSS con variables que se compilan en diferentes hojas de estilo.
3. Bibliotecas de JavaScript que manipulan din치micamente los estilos.

Pero cada una de estas soluciones tiene sus propios problemas. Las clases CSS se vuelven inmanejables, los preprocesadores requieren una compilaci칩n adicional, y las bibliotecas de JavaScript pueden ser pesadas y afectar el rendimiento.

** La soluci칩n: Simpleza y elegancia con Web Components

Entonces, 쯤u칠 hacemos? Bueno, en mi caso, como estoy usando Web Components personalizados (porque soy mas bien de backend y me gusta explorar tecnolog칤as del front ), se me ocurri칩 una idea: 쯏 si usamos las propias capacidades del navegador para manejar nuestros temas? 

As칤 naci칩 mi soluci칩n, que se basa en tres principios simples:

1. Un componente "core" que define todas las variables de color.
2. Variables CSS a nivel :root que todos los componentes pueden usar.
3. Componentes individuales que son "agn칩sticos" respecto al color real que est치n usando.

Suena simple, 쯨erdad? Pero como dicen, la belleza est치 en la simplicidad. Veamos c칩mo funciona esto en la pr치ctica.

*** El componente "core": ThemeSwitcher

Este es el coraz칩n de nuestra soluci칩n. Es un Web Component que se encarga de definir y aplicar nuestro tema de colores. Aqu칤 ten칠is un vistazo r치pido a c칩mo podr칤a verse:

#+BEGIN_SRC javascript
class ThemeSwitcher extends HTMLElement {
    constructor() {
        super();
        this.themes = {
            'light': {
                '--primary-color': '#4a90e2',
                '--background-color': '#f4f4f4',  
                // ... m치s colores ...
            },
            'dark': {
                '--primary-color': '#bb86fc',
                '--background-color': '#121212',
                // ... m치s colores ...  
            }
        };
    }

    connectedCallback() {
        this.applyTheme('light'); // Tema por defecto  
    }

    applyTheme(themeName) {
        const theme = this.themes[themeName];
        Object.entries(theme).forEach(([property, value]) => {
            document.documentElement.style.setProperty(property, value);
        });
    }
}

customElements.define('theme-switcher', ThemeSwitcher);
#+END_SRC

Este componente hace algo muy simple pero poderoso: define nuestros temas como objetos JavaScript y luego aplica esos temas estableciendo variables CSS en el elemento ra칤z del documento.

*** Los componentes "agn칩sticos": Usando las variables de color

Ahora, 쯖칩mo usan nuestros otros componentes estos colores? F치cil, simplemente hacen referencia a las variables CSS. Por ejemplo, un componente de bot칩n podr칤a verse as칤:

#+BEGIN_SRC javascript
class MyButton extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = `
            <style>
                button {
                    background-color: var(--primary-color);
                    color: var(--text-color);
                    border: none;
                    padding: 10px 20px;
                    cursor: pointer;
                }
            </style>
            <button><slot></slot></button>
        `;
    }
}

customElements.define('my-button', MyButton);
#+END_SRC

쯌eis c칩mo el bot칩n no sabe realmente qu칠 color es "--primary-color"? Solo sabe que debe usarlo para su fondo. Esto es lo que quiero decir con "agn칩stico de color".

Por el momento nada mas que colores , pero se puede extender a tipograf칤a, espaciado, etc.

Si estas pensando que eso hace dependiente al componente de las variables globales... tienes raz칩n, pero es un compromiso que estoy dispuesto a aceptar por la simplicidad y eficiencia que ofrece. 
Y si quieres que el componente sea agn칩stico de color, puedes pasarle las variables como propiedades.

Defines en el componente un atributo que se llama color y lo usas en el componente en lugar de las variables CSS. Es una de tantas posibilidades, pero aqu칤 nos centraremos solo en la base de la soluci칩n.

*** Poniendo todo junto 

Ahora, en nuestro HTML, podr칤amos tener algo as칤:

#+BEGIN_SRC html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mi Aplicaci칩n Tem치tica</title>
    <script type="module" src="theme-switcher.js"></script>
    <script type="module" src="my-button.js"></script>
</head>
<body>
    <theme-switcher id="themeSwitcher"></theme-switcher>
    <my-button>춰Haz clic!</my-button>
    <script>
        const switcher = document.getElementById('themeSwitcher');
        // Cambiamos al tema oscuro
        switcher.applyTheme('dark');  
    </script>
</body>
</html>
#+END_SRC

Y toma! Tenemos una aplicaci칩n con temas cambiables, sin necesidad de CSS gigante, sin preprocesadores, y sin bibliotecas pesadas de JavaScript.

** Que ventajas tiene esta soluci칩n?

1. *Rendimiento*: Las variables CSS son r치pidas. Muy r치pidas. Cambiar el tema es pr치cticamente instant치neo.
2. *Mantenibilidad*: Todos los colores est치n definidos en un solo lugar. 쯅ecesitas cambiar un color? Solo tienes que hacerlo una vez.
3. *Flexibilidad*: A침adir nuevos temas es tan simple como a침adir un nuevo objeto al componente ThemeSwitcher.
4. *Compatibilidad*: Esto funciona con cualquier framework (o sin framework). Los Web Components son est치ndar web.
5. *Escalabilidad*: Ya tengas 10 o 1000 componentes, el sistema funciona igual de bien.

** Reflexiones finales: El poder de pensar diferente

Lo que me encanta de esta soluci칩n es c칩mo toma algo que tradicionalmente se ha visto como un problema de CSS y lo convierte en un problema de componentes. Es un cambio de perspectiva que abre nuevas posibilidades.

Y lo mejor es que esto es solo el principio. Podr칤as expandir este concepto para manejar no solo colores, sino tambi칠n tipograf칤a, espaciado, o incluso animaciones. El cielo es el l칤mite cuando empiezas a pensar en t칠rminos de componentes y propiedades din치micas.

As칤 que la pr칩xima vez que os enfrent칠is a un problema que parece complicado, esto me recuerda que a veces, la soluci칩n m치s elegante es tambi칠n la m치s simple. Creo que debemos cuestionar las convenciones y buscar nuevas formas de abordar esos viejos problemas.

y ahora

** TODO Pr칩ximos pasos
- Implementar una interfaz de usuario para cambiar temas 
- Explorar c칩mo manejar preferencias de usuario (por ejemplo, guardar el tema preferido en localStorage) 
- Investigar c칩mo esta t칠cnica podr칤a aplicarse a otros aspectos del dise침o, como la tipograf칤a o el espaciado
- En el back Crear un controller especifico que use el wrapper PHP de pandoc para renderizar el contenido de los post en HTML , ya que se guardan en texto plano formato .org

쯈u칠 opin치is de esta aproximaci칩n? 쮿ab칠is usado t칠cnicas similares en vuestros proyectos? 춰Me encantar칤a escuchar vuestras experiencias dejadme un comentario !

**Actualizacion: Ya que estamos lo vamos a hacer.

Se me ha ocurrido usar y hacer un ThemeToggler en este mismo post que estas leyendo. Es ese boton que hay por ahi :D
Por supuesto se usa para todos los componentes de mi SPA. 

춰Y aqu칤 es donde la magia realmente sucede! Despu칠s de todo nuestro trabajo en la plantilla y el dise침o, hemos logrado algo verdaderamente emocionante: la integraci칩n perfecta de nuestro componente ThemeToggler en la plantilla generada por Pandoc.
Os voy a contar c칩mo llegamos aqu칤 , si es que a칰n no lo has visto en la parte superior derecha de esta p치gina.
Hasta ahora la plantilla de Pandoc tenia un tema "fijo" ahora eso ha cambiado, ahora el tema es din치mico y se puede cambiar en tiempo real.
Puedes verlo y probarlo en la parte superior derecha de esta p치gina, y a partir de ahora en toda la SPA de este blog.

** 쮺칩mo lo he integrado? 

1. *Creaci칩n del componente*: Primero, desarrollamos nuestro ThemeToggler como un Web Component independiente. Este componente encapsula toda la l칩gica para cambiar entre temas de color.
    [[https://github.com/pascualmg/cohete/blob/main/src/ddd/Infrastructure/webserver/html/js/atomic/organism/ThemeToogler.js][C칩digo fuente del ThemeToggler]]

2. *Dise침o de la plantilla*: Luego, dise침amos nuestra plantilla HTML para Pandoc, incluyendo un espacio para nuestro ThemeToggler en el header fijo. 

3. *Importaci칩n del componente*: En la plantilla, a침adimos una l칤nea para importar nuestro ThemeToggler:
   #+BEGIN_SRC html
   <script type="module" src="../../html/js/atomic/organism/ThemeToogler.js"></script>
   #+END_SRC

4. *Uso del componente*: Colocamos la etiqueta del componente en nuestra plantilla:
   #+BEGIN_SRC html 
   <theme-toggler></theme-toggler>
   #+END_SRC

5. *Generaci칩n del HTML*: Finalmente, usamos Pandoc para generar nuestro HTML final:
   #+BEGIN_SRC bash
   pandoc --template=/home/passh/src/php/cohete/src/ddd/Infrastructure/webserver/html/org/template.html --toc --toc-depth=2 eltemadeltema.org -o eltemadeltema.html
   #+END_SRC

** Aprovechando al m치ximo nuestro ThemeToogler 

En esta 칰ltima actualizaci칩n, quer칤a remarcar un par de puntos sobre nuestro componente ThemeToogler:

1. *Flexibilidad en el dise침o*: Aunque aqu칤 hemos implementado el ThemeToogler como un simple bot칩n, las posibilidades son infinitas. Podr칤amos hacerlo como un men칰 desplegable, un conjunto de botones de radio, o incluso un selector de colores completamente personalizable. La belleza de los Web Components es que encapsulan su funcionalidad, por lo que podemos cambiar su apariencia y comportamiento sin afectar al resto de nuestro c칩digo.

2. *Posibilidades de automatizaci칩n*: Con un peque침o ajuste, podr칤amos hacer que nuestro ThemeToogler cambie autom치ticamente seg칰n diferentes criterios. Por ejemplo, podr칤a cambiar a un tema oscuro durante las horas nocturnas, o podr칤a detectar la preferencia de tema del sistema operativo del usuario y ajustarse en consecuencia. Todo esto se podr칤a lograr sin cambiar ning칰n otro componente, gracias a la naturaleza modular de los Web Components.

3. *Integraci칩n inmediata*: Una de las mejores partes de todo esto es que, a partir de ahora, todos los nuevos componentes que cree para mi sitio web y mi portfolio heredar치n autom치ticamente esta funcionalidad de cambio de tema. No necesitar칠 escribir ning칰n c칩digo adicional o hacer ninguna configuraci칩n especial. Simplemente funcionar치, porque los colores se definen a nivel global y todos los componentes los respetan.

1. *Reutilizaci칩n de c칩digo*: Estamos reutilizando nuestro ThemeToggler en m칰ltiples p치ginas sin tener que copiar y pegar c칩digo.
2. *Encapsulaci칩n*: Toda la l칩gica del cambio de tema est치 contenida en el componente, manteniendo nuestra plantilla limpia y f치cil de mantener.
3. *Nativo y ligero*: Al usar Web Components nativos, no dependemos de frameworks pesados. Esto hace que nuestras p치ginas sean m치s r치pidas y eficientes.
4. *Compatibilidad*: Los Web Components son compatibles con la mayor칤a de los navegadores modernos, lo que significa que nuestro ThemeToggler funcionar치 en casi cualquier lugar.
5. *Flexibilidad*: Podemos f치cilmente actualizar o modificar el ThemeToogler sin tener que tocar el resto de nuestra plantilla o contenido.

** Conclusi칩n

Los Web Components ofrecen todas estas ventajas. Adem치s, al ser una tecnolog칤a nativa del navegador, se alinean perfectamente con mi filosof칤a de mantener las cosas simples y eficientes en mis proyectos.

*** Jappy Coding 游 !!!
