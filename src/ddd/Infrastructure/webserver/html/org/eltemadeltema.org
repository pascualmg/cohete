#+TITLE: El tema del tema: KISS con Web Components
#+AUTHOR: Pascual M.G.
#+DATE: <2024-07-04 Thu>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="spacemacs.css">


¬°Hola, compa√±eros desarrolladores! ¬øAlguna vez os hab√©is encontrado luchando con la gesti√≥n de temas de colores en vuestros proyectos web? Si es as√≠, ¬°no est√°is solos! Este quebradero de cabeza es tan com√∫n como frustrante. Pero no tem√°is, porque hoy vamos a sumergirnos en una soluci√≥n que, aunque simple, es sorprendentemente efectiva.

** El problema: Cuando los colores se vuelven un caos

Imaginad que est√°is construyendo una aplicaci√≥n web compleja. Ten√©is decenas, quiz√°s cientos de componentes. Botones, formularios, paneles, modales... y todos necesitan seguir un esquema de colores coherente. Ahora, a√±adid a eso la necesidad de tener m√∫ltiples temas (modo claro, modo oscuro, ¬°tal vez incluso un modo "disco" para los viernes por la noche!). De repente, lo que parec√≠a un simple juego de colores se convierte en un problema log√≠stico de proporciones √©picas.

Tradicionalmente, muchos desarrolladores han recurrido a soluciones como:

1. Clases CSS gigantes que definen cada color para cada elemento.
2. Preprocesadores CSS con variables que se compilan en diferentes hojas de estilo.
3. Bibliotecas de JavaScript que manipulan din√°micamente los estilos.

Pero cada una de estas soluciones tiene sus propios problemas. Las clases CSS se vuelven inmanejables, los preprocesadores requieren una compilaci√≥n adicional, y las bibliotecas de JavaScript pueden ser pesadas y afectar el rendimiento.

** La soluci√≥n: Simpleza y elegancia con Web Components

Entonces, ¬øqu√© hacemos? Bueno, en mi caso, como estoy usando Web Components personalizados (porque soy un poco rebelde y me gusta hacer las cosas a mi manera), se me ocurri√≥ una idea: ¬øY si usamos las propias capacidades del navegador para manejar nuestros temas?

As√≠ naci√≥ mi soluci√≥n, que se basa en tres principios simples:

1. Un componente "cerebro" que define todas las variables de color.
2. Variables CSS a nivel :root que todos los componentes pueden usar.
3. Componentes individuales que son "agn√≥sticos" respecto al color real que est√°n usando.

Suena simple, ¬øverdad? Pero como dicen, la belleza est√° en la simplicidad. Veamos c√≥mo funciona esto en la pr√°ctica.

*** El componente "cerebro": ThemeSwitcher

Este es el coraz√≥n de nuestra soluci√≥n. Es un Web Component que se encarga de definir y aplicar nuestro tema de colores. Aqu√≠ ten√©is un vistazo r√°pido a c√≥mo podr√≠a verse:

#+BEGIN_SRC javascript
class ThemeSwitcher extends HTMLElement {
    constructor() {
        super();
        this.themes = {
            'light': {
                '--primary-color': '#4a90e2',
                '--background-color': '#f4f4f4',
                // ... m√°s colores ...
            },
            'dark': {
                '--primary-color': '#bb86fc',
                '--background-color': '#121212',
                // ... m√°s colores ...
            }
        };
    }

    connectedCallback() {
        this.applyTheme('light'); // Tema por defecto
    }

    applyTheme(themeName) {
        const theme = this.themes[themeName];
        Object.entries(theme).forEach(([property, value]) => {
            document.documentElement.style.setProperty(property, value);
        });
    }
}

customElements.define('theme-switcher', ThemeSwitcher);
#+END_SRC

Este componente hace algo muy simple pero poderoso: define nuestros temas como objetos JavaScript y luego aplica esos temas estableciendo variables CSS en el elemento ra√≠z del documento.

*** Los componentes "agn√≥sticos": Usando las variables de color

Ahora, ¬øc√≥mo usan nuestros otros componentes estos colores? F√°cil, simplemente hacen referencia a las variables CSS. Por ejemplo, un componente de bot√≥n podr√≠a verse as√≠:

#+BEGIN_SRC javascript
class MyButton extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = `
            <style>
                button {
                    background-color: var(--primary-color);
                    color: var(--text-color);
                    border: none;
                    padding: 10px 20px;
                    cursor: pointer;
                }
            </style>
            <button><slot></slot></button>
        `;
    }
}

customElements.define('my-button', MyButton);
#+END_SRC

¬øVeis c√≥mo el bot√≥n no sabe realmente qu√© color es "--primary-color"? Solo sabe que debe usarlo para su fondo. Esto es lo que quiero decir con "agn√≥stico de color".

*** Poniendo todo junto

Ahora, en nuestro HTML, podr√≠amos tener algo as√≠:

#+BEGIN_SRC html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mi Aplicaci√≥n Tem√°tica</title>
    <script type="module" src="theme-switcher.js"></script>
    <script type="module" src="my-button.js"></script>
</head>
<body>
    <theme-switcher id="themeSwitcher"></theme-switcher>
    <my-button>¬°Haz clic!</my-button>
    <script>
        const switcher = document.getElementById('themeSwitcher');
        // Cambiamos al tema oscuro
        switcher.applyTheme('dark');
    </script>
</body>
</html>
#+END_SRC

Y voil√†! Tenemos una aplicaci√≥n con temas cambiables, sin necesidad de CSS gigante, sin preprocesadores, y sin bibliotecas pesadas de JavaScript.

** Las ventajas: ¬øPor qu√© esto mola tanto?

1. *Rendimiento*: Las variables CSS son r√°pidas. Muy r√°pidas. Cambiar el tema es pr√°cticamente instant√°neo.
2. *Mantenibilidad*: Todos los colores est√°n definidos en un solo lugar. ¬øNecesitas cambiar un color? Solo tienes que hacerlo una vez.
3. *Flexibilidad*: A√±adir nuevos temas es tan simple como a√±adir un nuevo objeto al componente ThemeSwitcher.
4. *Compatibilidad*: Esto funciona con cualquier framework (o sin framework). Los Web Components son est√°ndar web.
5. *Escalabilidad*: Ya tengas 10 o 1000 componentes, el sistema funciona igual de bien.

** Reflexiones finales: El poder de pensar diferente

Lo que me encanta de esta soluci√≥n es c√≥mo toma algo que tradicionalmente se ha visto como un problema de CSS y lo convierte en un problema de componentes. Es un cambio de perspectiva que abre nuevas posibilidades.

Y lo mejor es que esto es solo el principio. Podr√≠as expandir este concepto para manejar no solo colores, sino tambi√©n tipograf√≠a, espaciado, o incluso animaciones. El cielo es el l√≠mite cuando empiezas a pensar en t√©rminos de componentes y propiedades din√°micas.

As√≠ que la pr√≥xima vez que os enfrent√©is a un problema que parece complicado, recordad: a veces, la soluci√≥n m√°s elegante es tambi√©n la m√°s simple. No teng√°is miedo de cuestionar las convenciones y buscar nuevas formas de abordar viejos problemas.

Y ahora, ¬°a por ese modo "disco" para los viernes por la noche! üï∫üíÉ

** TODO Pr√≥ximos pasos
- Implementar una interfaz de usuario para cambiar temas
- Explorar c√≥mo manejar preferencias de usuario (por ejemplo, guardar el tema preferido en localStorage)
- Investigar c√≥mo esta t√©cnica podr√≠a aplicarse a otros aspectos del dise√±o, como la tipograf√≠a o el espaciado

¬øQu√© opin√°is de esta aproximaci√≥n? ¬øHab√©is usado t√©cnicas similares en vuestros proyectos? ¬°Me encantar√≠a escuchar vuestras experiencias y pensamientos en los comentarios!


* ThemeToggler en este mismo post que estas leyendo

¬°Y aqu√≠ es donde la magia realmente sucede! Despu√©s de todo nuestro trabajo en la plantilla y el dise√±o, hemos logrado algo verdaderamente emocionante: la integraci√≥n perfecta de nuestro componente ThemeToggler en la plantilla generada por Pandoc. Os voy a contar c√≥mo llegamos aqu√≠ y por qu√© esto es tan genial.
Hasta ahora la plantilla de Pandoc tenia un tema "fijo" ahora eso ha cambiado, ahora el tema es din√°mico y se puede cambiar en tiempo real.
Puedes verlo y probarlo en la parte superior derecha de esta p√°gina , y a partir de ahora en toda la SPA de este blog.

** C√≥mo lo he integrado ?

1. *Creaci√≥n del componente*: Primero, desarrollamos nuestro ThemeToggler como un Web Component independiente. Este componente encapsula toda la l√≥gica para cambiar entre temas de color.
    https://github.com/pascualmg/cohete/blob/main/src/ddd/Infrastructure/webserver/html/js/atomic/organism/ThemeToogler.js

2. *Dise√±o de la plantilla*: Luego, dise√±amos nuestra plantilla HTML para Pandoc, incluyendo un espacio para nuestro ThemeToggler en el header fijo.

3. *Importaci√≥n del componente*: En la plantilla, a√±adimos una l√≠nea para importar nuestro ThemeToggler:
   #+BEGIN_SRC html
   <script type="module" src="../../html/js/atomic/organism/ThemeToogler.js"></script>
   #+END_SRC

4. *Uso del componente*: Colocamos la etiqueta del componente en nuestra plantilla:
   #+BEGIN_SRC html
   <theme-toggler></theme-toggler>
   #+END_SRC

5. *Generaci√≥n del HTML*: Finalmente, usamos Pandoc para generar nuestro HTML final:
   #+BEGIN_SRC bash
   pandoc --template=/home/passh/src/php/cohete/src/ddd/Infrastructure/webserver/html/org/template.html --toc --toc-depth=2 eltemadeltema.org -o eltemadeltema.html
   #+END_SRC

** ¬øPor qu√© es esto tan genial?

1. *Reutilizaci√≥n de c√≥digo*: Estamos reutilizando nuestro ThemeToggler en m√∫ltiples p√°ginas sin tener que copiar y pegar c√≥digo.

2. *Encapsulaci√≥n*: Toda la l√≥gica del cambio de tema est√° contenida en el componente, manteniendo nuestra plantilla limpia y f√°cil de mantener.

3. *Nativo y ligero*: Al usar Web Components nativos, no dependemos de frameworks pesados. Esto hace que nuestras p√°ginas sean m√°s r√°pidas y eficientes.

4. *Compatibilidad*: Los Web Components son compatibles con la mayor√≠a de los navegadores modernos, lo que significa que nuestro ThemeToggler funcionar√° en casi cualquier lugar.

5. *Flexibilidad*: Podemos f√°cilmente actualizar o modificar el ThemeToggler sin tener que tocar el resto de nuestra plantilla o contenido.

** ¬øCon que motivaci√≥n?

 Mientras trabajaba en el dise√±o de la plantilla, me di cuenta de que quer√≠a algo que:

1. Fuera f√°cil de integrar en cualquier p√°gina.
2. No dependiera de un framework espec√≠fico.
3. Pudiera manejar su propio estado y l√≥gica.

Los Web Components ofrecen todas estas ventajas. Adem√°s, al ser una tecnolog√≠a nativa del navegador, se alinean perfectamente con mi filosof√≠a de mantener las cosas simples y eficientes.

La verdadera revelaci√≥n vino cuando me di cuenta de que pod√≠a incluir este componente directamente en mi plantilla de Pandoc. Esto significa que cada vez que genero una nueva p√°gina de mi blog, autom√°ticamente tiene la funcionalidad de cambio de tema, sin necesidad de c√≥digo adicional.

** Conclusi√≥n

Esta integraci√≥n demuestra el poder de pensar en componentes y de utilizar tecnolog√≠as web nativas. No solo hemos creado una soluci√≥n elegante para el cambio de temas, sino que tambi√©n hemos establecido un patr√≥n que podemos seguir para futuros componentes.

Imaginad las posibilidades: podr√≠amos crear componentes para comentarios, para compartir en redes sociales, para visualizaci√≥n de datos, y m√°s. Todos estos podr√≠an integrarse f√°cilmente en nuestra plantilla Pandoc, permiti√©ndonos crear p√°ginas ricas en funcionalidades con un esfuerzo m√≠nimo.

Este enfoque nos permite mantener la simplicidad y eficiencia de Markdown y Pandoc para el contenido, mientras aprovechamos toda la potencia de los Web Components para funcionalidades avanzadas. Es lo mejor de ambos mundos, y personalmente, estoy emocionado por explorar m√°s esta direcci√≥n en el futuro.

¬øQu√© opin√°is? ¬øVeis otras formas en las que podr√≠amos aprovechar los Web Components en nuestro flujo de trabajo con Pandoc?