* Reactor
:PROPERTIES:
:CUSTOM_ID: reactor
:END:
Rx in a sleek API server [[file:logo.png]]

** Powered by
:PROPERTIES:
:CUSTOM_ID: powered-by
:END:
*** 
:PROPERTIES:
:CUSTOM_ID: section
:END:

** Descripci√≥n
:PROPERTIES:
:CUSTOM_ID: descripci√≥n
:END:
Reactor, es un proyecto que he dise√±ado para facilitar la programaci√≥n
as√≠ncrona en PHP.

Este proyecto se construye sobre las s√≥lidas bases de ReactPHP y RxPHP,
ofreci√©ndote un camino hacia la programaci√≥n reactiva en PHP. Reactor
funciona como m√°s que una simple herramienta; es un marco de trabajo
estructurado en torno al Domain-Driven Design (DDD), con su n√∫cleo
contenido en unos pocos archivos sencillos de encontrar y entender. Con
esas dos librer√≠as de base se consigue un nuevo nivel de eficiencia y
rendimiento. Podr√°s manejar casos de uso de manera no bloqueante y
realizar m√∫ltiples tareas simult√°neamente.

La instalaci√≥n de Reactor es todo menos complicada, se utiliza como
plantilla que ya funciona y se pueden seguir los ejemplos o hacer algo
diferente.

Por supuesto, m√°s que un framework, es un espacio para el aprendizaje y
la exploraci√≥n. Es una invitaci√≥n a los autodidactas, a quienes aman
descubrir, aprender y compartir sus ideas. Te invito a explorar Reactor,
a sumergirte en su c√≥digo, a desafiar tus propios l√≠mites y a compartir
tus descubrimientos y experiencias. Si tienes inter√©s por la
programaci√≥n reactiva y PHP, te invito a que lo pruebes

* Estructura del Proyecto

La organizaci√≥n de este proyecto gira alrededor del concepto DDD (Dise√±o Guiado por Dominio). Para que te hagas una idea, el esquema a continuaci√≥n te da una representaci√≥n de alto nivel:

#+BEGIN_EXAMPLE
.
‚îú‚îÄ‚îÄ src                # Aqu√≠ vive el c√≥digo fuente
‚îÇ   ‚îî‚îÄ‚îÄ ddd            # Zona DDD
‚îÇ       ‚îú‚îÄ‚îÄ Application
‚îÇ       ‚îú‚îÄ‚îÄ Domain
‚îÇ       ‚îú‚îÄ‚îÄ Infrastructure
‚îÇ       ‚îî‚îÄ‚îÄ Presentation
‚îú‚îÄ‚îÄ tests              # Aqu√≠ alojamos los tests.
‚îú‚îÄ‚îÄ vendor             # Dependencias que composer se encarga de gestionar
‚îî‚îÄ‚îÄ bootstrap.php      # Ejec√∫talo y la app arranca.
#+END_EXAMPLE

* src/ddd: Aqu√≠ es donde la magia del DDD sucede. Tenemos varios subdirectorios, cada uno se ocupa de un aspecto diferente de DDD.
  - Application: Aqu√≠, tenemos los casos de uso y servicios de la aplicaci√≥n.

Y mientras todo esto sucede, cuento con un poco de ayuda de mi lado. Maikel, un asistente AI, me est√° ayudando a generar este texto. De hecho, este documento puede ser m√°s complejo de lo que parece a primera vista, dado que soy el √∫nico colaborador trabajando actualmente en este proyecto, cada peque√±o ahorro de tiempo cuenta.

* Pero, ¬øpor qu√© una plantilla de GitHub?

En las primeras etapas de desarrollo de un proyecto, una plantilla de GitHub puede ser un recurso valioso. Proporciona una estructura de directorio ya definida y archivos preconfigurados para que puedas comenzar a trabajar de inmediato, minimizando la cantidad de configuraci√≥n inicial necesaria por parte del usuario. Creemos que esto es especialmente valioso en nuestro caso, ya que esperamos que sea m√°s f√°cil tanto trabajar con nuestro proyecto, como contribuir a √©l.
* Instalaci√≥n
:PROPERTIES:
:CUSTOM_ID: instalaci√≥n
:END:
#+begin_src sh
make nix-install 

nix develop 
make run
#+end_src

** Tip: Configuraci√≥n Adicional de =direnv=
:PROPERTIES:
:CUSTOM_ID: tip-configuraci√≥n-adicional-de-direnv
:END:
Si deseas simplificar tu flujo de trabajo evitando la necesidad de
ejecutar =nix develop= cada vez que ingresas al directorio del proyecto,
puedes optar por la configuraci√≥n adicional con =direnv=:

1. Aseg√∫rate de tener =direnv= instalado. Puedes confirmar esto
   ejecutando =direnv= en tu consola. Si el comando no se encuentra,
   necesitas instalar =direnv=.

2. Configura tu shell para utilizar =direnv=. Si est√°s usando =bash=,
   puedes agregar la siguiente l√≠nea a tu archivo =.bashrc=. Si est√°s
   usando =zsh=, agrega la misma l√≠nea a tu archivo =.zshrc=.

   #+begin_src sh
   eval "$(direnv hook bash)"
   # o
   eval "$(direnv hook zsh)"
   #+end_src

3. Reinicia tu consola para que los cambios en tu archivo de
   configuraci√≥n de shell tengan efecto.

4. Verifica que tu archivo =.envrc= est√° en el directorio correcto y
   tiene los valores correctos.

5. Cuando entras a tu directorio (en este caso, el directorio =rxphp=),
   deber√≠as ver un mensaje de =direnv= solicit√°ndote permitir el uso del
   archivo =.envrc=. Usa el comando =direnv allow= para esto.

Si despu√©s de seguir estos pasos, =direnv= a√∫n no funciona como se
esperaba, verifica los detalles de tu instalaci√≥n y configuraci√≥n.

** Caracter√≠sticas
:PROPERTIES:
:CUSTOM_ID: caracter√≠sticas
:END:
- Mejora la eficiencia y el rendimiento evitando bloquear el hilo
  principal con operaciones intensivas de E/S.
- Ofrece un control granular sobre la ejecuci√≥n de las tareas.
- Extiende las capacidades de PHP m√°s all√° de las aplicaciones web
  s√≠ncronas tradicionales.

Las posibilidades con PHP son extensas. Reactor es un ejemplo de esto.
Este proyecto es un terreno abierto para el intercambio de ideas y el
aprendizaje mutuo. Cualquier contribuci√≥n para su mejora es bienvenida y
se considera valiosa.

** Manejo as√≠ncrono de las peticiones (the core)
:PROPERTIES:
:CUSTOM_ID: manejo-as√≠ncrono-de-las-peticiones-the-core
:END:
Al crear el servidor HTTP con ReactPHP, se le pasa una funci√≥n de manejo
de peticiones. Aqu√≠ est√° la funci√≥n an√≥nima que se pasa al servidor:

#+begin_src php
        $httpServer = new HttpServer(
            $clientIPMiddleware,
            function (ServerRequestInterface $request) use ($container, $dispatcher) : PromiseInterface | ResponseInterface {
                try {
                    return self::AsyncHandleRequest(
                        $request,
                        $container,
                        $dispatcher
                    )
                        ->then(function (ResponseInterface $response) {
                            return $response;
                        })
                        ->catch(function (Throwable $exception) {
                            return new Response(
                                409,
                                ['Content-Type' => 'application/json'],
                                self::toJson($exception)
                            );
                        });
                } catch (Throwable $exception) {
                    // Capture only router configuration errors &
                    // other exceptions not related to request handling
                    return new Response(
                        500,
                        ['Content-Type' => 'application/json'],
                        self::toJson($exception)
                    );
                }
            }
        );
#+end_src

En la funci√≥n de manejo de peticiones que se pasa al servidor HTTP de
ReactPHP, la petici√≥n se procesa de manera as√≠ncrona mediante la
invocaci√≥n de la funci√≥n =AsyncHandleRequest=. Esta funci√≥n procesa la
petici√≥n y devuelve una promesa. Esta promesa se resolver√° con un objeto
implementando =ResponseInterface= y esa respuesta ser√° la que ReactPHP
enviar√° al cliente HTTP.

Esto es posible gracias a la naturaleza as√≠ncrona y no bloqueante de
ReactPHP, que permite realizar operaciones de E/S ( como leer de una
base de datos o hacer una solicitud HTTP a otra API) dentro de la
funci√≥n de manejo sin bloquear el hilo de ejecuci√≥n principal de la
aplicaci√≥n. Estas operaciones de E/S son as√≠ncronas y devuelven una
promesa.

Por lo tanto, al devolverse una promesa en las funciones de manejo,
ReactPHP espera a que esta promesa se resuelva antes de enviar la
respuesta al cliente HTTP. Esto permite realizar operaciones de E/S
as√≠ncronas y simplemente devolver una promesa que se resolver√° con la
respuesta cuando todas las operaciones de E/S hayan finalizado.

En situaciones de error no relacionados con el manejo de la petici√≥n
(como errores de configuraci√≥n del enrutador), la funci√≥n de manejo
puede devolver directamente una respuesta con un c√≥digo de estado HTTP
500 o similar, lo cual proporciona flexibilidad para manejar diversas
situaciones de error a nivel del servidor.

Esta capacidad de manejar las peticiones de forma as√≠ncrona es
especialmente valiosa en situaciones donde hay operaciones de E/S con un
potencial de latencia alta. Por ejemplo, un servidor que tenga que
buscar datos en una base de datos remota para cada petici√≥n se
beneficiar√≠a enormemente de esta caracter√≠stica. En un modelo de
ejecuci√≥n sincr√≥nico, el servidor debe esperar a que se complete la
operaci√≥n de la base de datos antes de poder procesar la siguiente
petici√≥n. Sin embargo, con ReactPHP y su modelo as√≠ncrono, el servidor
puede procesar varias peticiones a la vez, mientras espera la respuesta
de la base de datos. Mientras una petici√≥n est√° en espera, otras
peticiones pueden ser procesadas y enviadas, utilizando de manera
eficiente el tiempo de CPU y mejorando significativamente el rendimiento
y la capacidad de respuesta del servidor.

Adem√°s, debido a que ReactPHP es no bloqueante, incluso con un n√∫mero
grande de peticiones simult√°neas, otras partes de tu aplicaci√≥n o de tu
sistema no se ver√°n afectadas y podr√°n seguir funcionando con
normalidad. Esto hace a ReactPHP una excelente opci√≥n para aplicaciones
que necesiten mantener un alto nivel de rendimiento y eficiencia,
incluso bajo una carga pesada de peticiones.

En resumen, la capacidad de ReactPHP para manejar peticiones de manera
as√≠ncrona significa que puede proporcionar un servicio r√°pido y
eficiente, incluso en situaciones donde un servidor s√≠ncrono se
bloquear√≠a o se ralentizar√≠a.

* PHP As√≠ncrono: Una Nueva Perspectiva
:PROPERTIES:
:CUSTOM_ID: php-as√≠ncrono-una-nueva-perspectiva
:END:
PHP, conocido por su uso tradicional en desarrollo web s√≠ncrono, puede
ser tambi√©n muy potente en contextos as√≠ncronos, permiti√©ndonos
optimizar la eficiencia de nuestras aplicaciones. Cambiar nuestro "chip"
para adoptar este enfoque puede parecer complejo, pero en realidad nos
abre una puerta a nuevas y apasionantes posibilidades.

** Cambiando el paradigma
:PROPERTIES:
:CUSTOM_ID: cambiando-el-paradigma
:END:
La programaci√≥n as√≠ncrona significa que podemos empezar tareas sin tener
que esperar a que otras terminen, permitiendo a nuestro c√≥digo avanzar
sin quedar bloqueado. Este enfoque es particularmente √∫til para tareas
que dependen de la entrada/salida (I/O), como las operaciones de red,
lectura/escritura de archivos, interacciones con bases de datos, entre
otras.

Nuestro enfoque para explicar este cambio de paradigma ser√° a trav√©s de
dos casos de uso: =FindAllPostController= y =FindPostById=. Aunque los
detalles espec√≠ficos y el c√≥digo ser√°n a√±adidos posteriormente, lo
importante a recordar es c√≥mo aprovechamos esta asincron√≠a en nuestra
l√≥gica de negocio.

** Declarativo sobre Imperativo
:PROPERTIES:
:CUSTOM_ID: declarativo-sobre-imperativo
:END:
La clave del enfoque as√≠ncrono es adoptar un estilo de programaci√≥n m√°s
declarativo que imperativo. En lugar de decir c√≥mo hacer algo con
instrucciones detalladas, describimos qu√© queremos lograr y dejamos que
el sistema decida c√≥mo implementarlo. Esto es particularmente evidente
en DDD (Domain-Driven Design), donde nuestro c√≥digo refleja el dominio
del negocio de forma m√°s clara y abstracta.

Nuestra estrategia ser√° recibir una petici√≥n, iniciar la l√≥gica de
negocio correspondiente, y devolver una respuesta sin tener que esperar
a que esta l√≥gica termine completamente. Esto permite mantener la
agilidad de nuestra aplicaci√≥n, mejorando la experiencia de usuario al
minimizar los tiempos de espera.

Este cambio de "chip" puede ser desafiante, pero las recompensas en
t√©rminos de eficiencia y rendimiento son enormes. Te invitamos a
descubrir m√°s a medida que profundizamos en estos casos de uso con PHP
as√≠ncrono.

* Algunas üîã incluidas
:PROPERTIES:
:CUSTOM_ID: algunas-incluidas
:END:
Este framework ofrece una serie de caracter√≠sticas robustas para los
proyectos que buscan optimizar la eficiencia y rendimiento en tareas
as√≠ncronas con PHP.

** Contenedor de Dependencias con Autowiring
:PROPERTIES:
:CUSTOM_ID: contenedor-de-dependencias-con-autowiring
:END:

Implementado con PHP-DI, el contenedor de dependencias, facilita la
gesti√≥n de las dependencias de la aplicaci√≥n y contribuye a un dise√±o de
c√≥digo limpio y de f√°cil mantenimiento.

** Enrutador
:PROPERTIES:
:CUSTOM_ID: enrutador
:END:
https://github.com/nikic/FastRoute Con el uso de FastRoute como
enrutador, el framework permite una definici√≥n y manejo claro de las
rutas en el c√≥digo, mejorando su legibilidad y acelerando el desarrollo.

** Bus As√≠ncrono
:PROPERTIES:
:CUSTOM_ID: bus-as√≠ncrono
:END:
El bus as√≠ncrono, basado en ReactPHP y Evenement, gestiona
eficientemente la comunicaci√≥n entre las diversas partes de la
aplicaci√≥n, mejorando su rendimiento.

Aunque estas caracter√≠sticas ampl√≠an la funcionalidad, permanecen
completamente desacopladas del n√∫cleo del framework, que sigue siendo
una funci√≥n simples que recibe una solicitud y devuelve una respuesta.

** Migraciones y fixtures
:PROPERTIES:
:CUSTOM_ID: migraciones-y-fixtures
:END:
Para manejar las migraciones y fixtures de la base de datos en este
proyecto, se seleccion√≥ [[https://phinx.org][Phinx]] debido a su
versatilidad.

Puedes ejecutar las migraciones utilizando el comando make:

#+begin_src sh
make migrations
#+end_src

O puedes hacerlo directamente a trav√©s de Phinx con:

#+begin_src sh
./bin/vendor/phinx
#+end_src

Adem√°s, este proyecto utiliza
[[https://github.com/fzaninotto/Faker][Faker]] para generar fixtures.
Faker es una biblioteca PHP que genera datos ficticios para rellenar
nuestras bases de datos. Permite crear un conjunto de datos realistas,
haciendo que nuestras pruebas sean m√°s robustas.

Recuerda actualizar tus migraciones y fixtures seg√∫n sea necesario para
reflejar cualquier cambio en la estructura de tus datos. # Flexibilidad
y Facilidad de Modificaci√≥n

Las funcionalidades presentadas, como la arquitectura DDD, son
√∫nicamente una propuesta inicial. El framework est√° dise√±ado con una
arquitectura flexible que facilita la modificaci√≥n, adici√≥n o
eliminaci√≥n de funcionalidades seg√∫n sean necesarias. De esta manera, el
framework se puede ajustar para satisfacer las necesidades espec√≠ficas
de cada proyecto.

* Ejemplos de Mysql no bloqueante .
:PROPERTIES:
:CUSTOM_ID: ejemplos-de-mysql-no-bloqueante-.
:END:
** Una consulta simple
:PROPERTIES:
:CUSTOM_ID: una-consulta-simple
:END:
*tradicional*

#+begin_src php
public function findById(int $postId): ?Post 
{
    $mysqli = new mysqli("localhost", "usuario", "contrase√±a", "base_de_datos");

    $stmt = $mysqli->prepare("SELECT * FROM post WHERE post.id = ?");
    $stmt->bind_param("i", $postId);
    $stmt->execute();
    $result = $stmt->get_result();
    $rawPostData = $result->fetch_assoc();

    return $rawPostData === null ? null : new Post(
        $rawPostData['id'],
        $rawPostData['title'] . $rawPostData['content'],
        new \DateTimeImmutable($rawPostData['created_at'])
    );
}
#+end_src

*as√≠ncrono con Promises*

#+begin_src php
    public function findById(int $postId): PromiseInterface //of Post or Null
    {
        $deferred = new Deferred();

        $this->mysqlClient->query(
            "SELECT * FROM post where post.id = ?",
            [$postId]
        )->then(function (MysqlResult $mysqlResult) use ($deferred) {
            $rawPostData = $mysqlResult->resultRows[0] ?? null;

            $deferred->resolve(
                $rawPostData === null ? null : new Post(
                    $rawPostData['id'],
                    $rawPostData['title'] . $rawPostData['content'],
                    new \DateTimeImmutable($rawPostData['created_at'])
                )
            );
        });

        return $deferred->promise();
    }
#+end_src

** Ejemplo de transacci√≥n
:PROPERTIES:
:CUSTOM_ID: ejemplo-de-transacci√≥n
:END:
*tradicional*

#+begin_src php
$mysqli = new mysqli("localhost", "usuario", "contrase√±a", "base_de_datos");

$amount = 100; // Transferir $100 de la cuenta 1 a la cuenta 2
try {
    $mysqli->autocommit(FALSE);

    $stmt = $mysqli->prepare('UPDATE account SET balance = balance - ? WHERE id = 1');
    $stmt->bind_param("i", $amount);
    $stmt->execute();
    
    $stmt = $mysqli->prepare('UPDATE account SET balance = balance + ? WHERE id = 2');
    $stmt->bind_param("i", $amount);
    $stmt->execute();

    $mysqli->commit(); // Si todo fue exitoso, confirma la transacci√≥n
} catch (\Exception $e) {
    $mysqli->rollback(); // Si algo fall√≥, revierte la transacci√≥n
    throw $e; // Lanza la excepci√≥n para manejarla en el c√≥digo externo
};
#+end_src

*as√≠ncrono con promises*

#+begin_src php
use React\MySQL\ConnectionInterface;

$connection = new ConnectionInterface;  // Aseg√∫rate de tener una instancia de ConnectionInterface y reemplaza esto seg√∫n tu configuraci√≥n de conexi√≥n

$connection->query('BEGIN')
    ->then(function() use ($connection) {
        $amount = 100;  // Suponemos que estamos transfiriendo $100 de la cuenta 1 a la cuenta 2

        return $connection->query('UPDATE account SET balance = balance - ? WHERE id = 1', [$amount])
            ->then(function() use ($connection, $amount) {
                return $connection->query('UPDATE account SET balance = balance + ? WHERE id = 2', [$amount]);
            });
    })
    ->then(function () use ($connection) {
        return $connection->query('COMMIT');
    })
    ->catch(function (\Exception $e) use ($connection) {
        $connection->query('ROLLBACK');
        throw $e;
    });
#+end_src

*con rxPHP!? :)*

#+begin_src php
use React\MySQL\ConnectionInterface;
use Rx\Observable;

$connection = new ConnectionInterface; // Aseg√∫rate de tener una instancia de ConnectionInterface y reemplaza esto seg√∫n tu configuraci√≥n de conexi√≥n

// Iniciar la transacci√≥n
$beginTransaction = Observable::fromPromise($connection->query('BEGIN'));

// Enviar la consulta de debito
$debitAccount = Observable::fromPromise(
    $connection->query('UPDATE account SET balance = balance - ? WHERE id = 1', [$amount = 100]) // Transferir $100 de la cuenta 1 a la cuenta 2
);

// Enviar la consulta de credito
$creditAccount = Observable::fromPromise(
    $connection->query('UPDATE account SET balance = balance + ? WHERE id = 2', [$amount])
);

// Enviar el COMMIT si todo fue exitoso
$commitTransaction = Observable::fromPromise($connection->query('COMMIT'));

// Secuenciando las operaciones anteriores
$transaction = $beginTransaction
    ->concat($debitAccount)
    ->concat($creditAccount)
    ->concat($commitTransaction)
    ->share();

// Lidiando con los √©xitos
$transaction
    ->subscribe(
        function() { echo "Operaci√≥n exitosa \n"; },
        // En caso de error, hacer un rollback
        function(\Exception $e) use ($connection) {
            echo "Hubo un error, haciendo rollback \n";
            $connection->query('ROLLBACK');
            throw $e;
        },
        function() { echo "La transacci√≥n ha sido completada \n"; }
    );
#+end_src

** Utilizando Observables con ReactPHP y RxPHP
:PROPERTIES:
:CUSTOM_ID: utilizando-observables-con-reactphp-y-rxphp
:END:
Este proyecto explora c√≥mo manejar operaciones as√≠ncronas y no
bloqueantes utilizando ReactPHP y RxPHP. Este enfoque se activa al
inicio de la aplicaci√≥n estableciendo el Scheduler predeterminado de
RxPHP a una instancia de =Rx\Scheduler\EventLoopScheduler= que usa el
loop predeterminado de =react/event-loop=.

#+begin_src php
require_once 'vendor/autoload.php';

$loop = React\EventLoop\Loop::get();

$scheduler = new Rx\Scheduler\EventLoopScheduler($loop);

Rx\Scheduler::setDefaultFactory(function() use ($scheduler) {
return $scheduler;
});
#+end_src

Por supuesto es totalmente opcional :)

*** Un ejemplo ObservableFilePostRepository
:PROPERTIES:
:CUSTOM_ID: un-ejemplo-observablefilepostrepository
:END:
#+begin_src php
public function observableOfFile(): Observable
{
$loop = React\EventLoop\Loop::get();
$filesystem = React\Filesystem\Filesystem::create($loop);
$postFilePath = dirname(__DIR__).'/Post/posts.json';
$file = $filesystem->file($postFilePath);
$contents = $file->getContents();
return Rx\Observable::fromPromise($contents);
}
#+end_src

Esta funci√≥n devuelve un =Observable= que emitir√° el contenido del
archivo cuando est√© listo.

Luego, podemos mapear el contenido del archivo JSON a un array de posts:

#+begin_src php
->map(fn($file) => json_decode($file, true, 512, JSON_THROW_ON_ERROR))
#+end_src

Este c√≥digo lanzar√° una excepci√≥n =JsonException= si la decodificaci√≥n
del JSON falla. Este error debe ser gestionado apropiadamente.

Para procesar cada post, utilizamos =flatMap= para convertir el array de
posts en una secuencia de posts individuales, luego mapeamos cada post a
una entidad Post:

#+begin_src php
->flatMap(fn($posts) => Rx\Observable::fromArray($posts))
->map(fn($post) => self::hydrate($post))
#+end_src

Finalmente, convertimos nuestro =Observable= a una =PromiseInterface=
para su uso con ReactPHP:

#+begin_src php
->toArray()
->toPromise();
#+end_src

Si la operaci√≥n es exitosa, esta =PromiseInterface= se resolver√° con un
array de entjes como JavaScript con su modelo de manejo de eventos.

C√≥digo completo del m√©todo =findAll=:

#+begin_src php
public function findAll(): PromiseInterface
{
return $this->observableOfFile()
->map(fn($file) => json_decode($file, true, 512, JSON_THROW_ON_ERROR))
->flatMap(fn($posts) => Observable::fromArray($posts))
->map(fn($post) => self::hydrate($post))
->toArray()
->toPromise();
}
#+end_src

Como dec√≠a Kyle Simpson en 'You Don't Know JS' > "La familiaridad es la
clave para la comprensi√≥n"

* Kernel
:PROPERTIES:
:CUSTOM_ID: kernel
:END:
La clase =Kernel= es la piedra angular de nuestra aplicaci√≥n, encargada
de manejar todas las solicitudes HTTP entrantes. Opera en un paradigma
as√≠ncrono, asegurando que se devuelva una =ResponseInterface=, pero
siempre como una =PromiseInterface= para garantizar el principio no
bloqueante.

#+begin_src php
public function __invoke(ServerRequestInterface $request): PromiseInterface //of a ResponseInterface
#+end_src

La funci√≥n =__invoke= act√∫a como nuestra funci√≥n de entrada, se crea un
contenedor de dependencias y un router. El m√©todo =AsyncHandleRequest=
se utiliza para manejar la solicitud de manera asincrona. Si todo
funciona correctamente, simplemente entregamos la respuesta. Sin
embargo, si ocurre una excepci√≥n durante el manejo de la solicitud, esta
se atrapa y se convierte en una respuesta JSON con detalles del error.

Ahora, nos enfocamos en la l√≠nea 81, que es de vital importancia.

#+begin_src php
$response = $container->get($httpRequestHandlerName)($request, $params);
#+end_src

Esta l√≠nea lleva a cabo una funci√≥n cr√≠tica: utilizando el router,
determina cu√°l handler es responsable de gestionar la solicitud HTTP
para la ruta dada. El contenedor de dependencias PSR-11 se usa para
obtener una instancia de este handler. Este handler es √∫nico, ya que se
instanciar√° con todas las dependencias necesarias y recibir√° la
solicitud y los par√°metros como argumentos.

Este handler proporcionar√° un objeto =ResponseInterface=. Sin embargo,
necesitamos asegurarnos de que todav√≠a estamos funcionando
asincr√≥nicamente.

#+begin_src php
$deferred->resolve(
$response instanceof PromiseInterface ? $response : self::wrapWithPromise($response)
);
#+end_src

Entonces, si el handler devuelve una =ResponseInterface= en lugar de una
=PromiseInterface=, usamos =wrapWithPromise= para envolver la
=ResponseInterface= en una =PromiseInterface=. Esto garantiza que
siempre estamos devolviendo una promesa de una respuesta.

Es este delicado equilibrio el que nos permite mantener la asincron√≠a en
todo nuestro Kernel, mientras aprovechamos una estructura de handler de
solicitudes ordenada y predecible.

** ¬øPor qu√© estoy usando Web Components en este proyecto?
:PROPERTIES:
:CUSTOM_ID: por-qu√©-estoy-usando-web-components-en-este-proyecto
:END:
Es importante se√±alar que este proyecto es en esencia un backend. El uso
de tecnolog√≠as web en el mismo es en realidad bastante concreto y
principalmente est√° presente para mis propias pruebas. A pesar de ello,
siempre he tenido la curiosidad de explorar nuevas tecnolog√≠as y en esta
ocasi√≥n, encontr√© en los Web Components una oportunidad de aprendizaje
muy interesante.

Como desarrollador de backend, valoro especialmente las tecnolog√≠as que
brindan una gran longevidad y estabilidad, caracter√≠sticas que encuentro
en los Web Components. Los Web Components son un conjunto de
caracter√≠sticas nativas del navegador que permiten definir tus propios
componentes HTML personalizados.

Estos componentes pueden encapsular su propia funcionalidad y estilos,
lo m√°s importante, son compatibles con cualquier framework de
JavaScript, sea actual, futuro o simplemente sin la necesidad de ning√∫n
framework. Esta compatibilidad universal se debe al hecho de que los Web
Components se conforman a est√°ndares web duraderos.

Los Web Components emplean tecnolog√≠as como Custom Elements para definir
nuevos tipos de elementos HTML, Shadow DOM para aislar y encapsular los
componentes y HTML Templates para la reutilizaci√≥n de c√≥digo HTML. Al
usar estas tecnolog√≠as, puedo estar seguro de que el c√≥digo que escribo
hoy seguir√° siendo √∫til y relevante en el futuro, sin importar las
tendencias de los frameworks.

As√≠ que, en resumen, estoy usando Web Components en este proyecto para
garantizar que el c√≥digo resultante sea resistente, reutilizable y a
prueba de futuro. Si ma√±ana desaparece un framework en particular, mi
c√≥digo seguir√≠a funcionando perfectamente. Sin embargo, eso no significa
que no reconozca la utilidad y las ventajas que ciertos frameworks
pueden brindar. Simplemente es una manifestaci√≥n de mi deseo de buscar
soluciones robustas y duraderas.
